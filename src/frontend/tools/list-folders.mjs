#!/usr/bin/env node

/**
 * Folder Listing Tool
 * 
 * Generates a deterministic, stable-sorted folder tree for the repository.
 * Excludes common non-source directories and outputs in a readable format.
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Load configuration
const configPath = path.join(__dirname, 'list-folders.config.json');
let config = {
  ignoreDirs: [
    'node_modules',
    '.git',
    'dist',
    'build',
    '.dfx',
    'target',
    'coverage',
    '.next',
    '.cache',
    '.turbo',
    '.vercel',
    '.vscode',
    '.idea',
    'out',
    'tmp',
    'temp'
  ],
  maxDepth: 10,
  rootFolders: ['backend', 'frontend']
};

try {
  const configData = fs.readFileSync(configPath, 'utf-8');
  config = { ...config, ...JSON.parse(configData) };
} catch (error) {
  console.warn('Warning: Could not load config file, using defaults');
}

/**
 * Recursively walks a directory tree and collects folder paths
 * @param {string} dir - Directory to walk
 * @param {number} depth - Current depth
 * @param {string} prefix - Prefix for relative path
 * @returns {string[]} Array of folder paths
 */
function walkDirectory(dir, depth = 0, prefix = '') {
  if (depth > config.maxDepth) {
    return [];
  }

  const folders = [];
  
  try {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    
    // Sort entries alphabetically for deterministic output
    entries.sort((a, b) => a.name.localeCompare(b.name));
    
    for (const entry of entries) {
      if (!entry.isDirectory()) {
        continue;
      }
      
      // Skip ignored directories
      if (config.ignoreDirs.includes(entry.name)) {
        continue;
      }
      
      const relativePath = prefix ? `${prefix}/${entry.name}` : entry.name;
      folders.push(relativePath);
      
      // Recursively walk subdirectories
      const fullPath = path.join(dir, entry.name);
      const subFolders = walkDirectory(fullPath, depth + 1, relativePath);
      folders.push(...subFolders);
    }
  } catch (error) {
    console.error(`Error reading directory ${dir}:`, error.message);
  }
  
  return folders;
}

/**
 * Generates a tree-like string representation of folders
 * @param {string[]} folders - Array of folder paths
 * @returns {string} Tree representation
 */
function generateTree(folders) {
  const lines = [];
  
  for (const folder of folders) {
    const parts = folder.split('/');
    const depth = parts.length - 1;
    const indent = '  '.repeat(depth);
    const name = parts[parts.length - 1];
    lines.push(`${indent}${name}/`);
  }
  
  return lines.join('\n');
}

/**
 * Generates a markdown document with the folder tree
 * @param {string[]} folders - Array of folder paths
 * @returns {string} Markdown content
 */
function generateMarkdown(folders) {
  const timestamp = new Date().toISOString();
  
  let markdown = `# Repository Folder Structure

**Generated:** ${timestamp}

This document is auto-generated by the folder listing tool.
To regenerate, run: \`node frontend/tools/list-folders.mjs --output frontend/REPO_FOLDER_TREE.md\`

## Folder Tree

\`\`\`
`;
  
  markdown += generateTree(folders);
  markdown += '\n```\n\n';
  
  // Group by top-level folders
  const grouped = {};
  for (const folder of folders) {
    const topLevel = folder.split('/')[0];
    if (!grouped[topLevel]) {
      grouped[topLevel] = [];
    }
    grouped[topLevel].push(folder);
  }
  
  markdown += '## Folders by Category\n\n';
  
  for (const [topLevel, paths] of Object.entries(grouped).sort()) {
    markdown += `### ${topLevel}/\n\n`;
    for (const folderPath of paths) {
      markdown += `- ${folderPath}\n`;
    }
    markdown += '\n';
  }
  
  markdown += `---

*Total folders: ${folders.length}*
`;
  
  return markdown;
}

/**
 * Main execution
 */
function main() {
  const args = process.argv.slice(2);
  const outputIndex = args.indexOf('--output');
  const outputPath = outputIndex !== -1 ? args[outputIndex + 1] : null;
  
  // Determine repository root (two levels up from tools/)
  const repoRoot = path.resolve(__dirname, '..', '..');
  
  console.log(`Scanning repository at: ${repoRoot}`);
  console.log(`Ignoring: ${config.ignoreDirs.join(', ')}`);
  console.log('');
  
  // Collect all folders
  const allFolders = [];
  
  for (const rootFolder of config.rootFolders) {
    const rootPath = path.join(repoRoot, rootFolder);
    
    if (!fs.existsSync(rootPath)) {
      console.warn(`Warning: Root folder not found: ${rootFolder}`);
      continue;
    }
    
    // Add the root folder itself
    allFolders.push(rootFolder);
    
    // Walk the directory tree
    const subFolders = walkDirectory(rootPath, 0, rootFolder);
    allFolders.push(...subFolders);
  }
  
  // Sort for deterministic output
  allFolders.sort();
  
  if (outputPath) {
    // Generate markdown and write to file
    const markdown = generateMarkdown(allFolders);
    const fullOutputPath = path.resolve(repoRoot, outputPath);
    
    try {
      fs.writeFileSync(fullOutputPath, markdown, 'utf-8');
      console.log(`âœ“ Folder tree written to: ${outputPath}`);
      console.log(`  Total folders: ${allFolders.length}`);
    } catch (error) {
      console.error(`Error writing output file: ${error.message}`);
      process.exit(1);
    }
  } else {
    // Print to stdout
    console.log('Repository Folder Tree:');
    console.log('======================\n');
    console.log(generateTree(allFolders));
    console.log('');
    console.log(`Total folders: ${allFolders.length}`);
  }
}

main();
